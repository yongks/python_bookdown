
# Built-in Data Types

## Import Libraries

```{python}
import string
```

## Numbers (int/float)

Two types of built-in number type, **integer and float**.

```{python results='hold'}
n = 123       ## integer
type (n)

f = 123.4     ## float
type (f)
```

### Number Operators

In general, when the operation potentially return **float**, the result is float.  Otherwise it return **integer**.

**Division** always return float

```{python, results='hold'}
4/2          ## return float
type(4/2)   
```

**Integer Division** returns int or float

```{python, results='hold'}
8//3         ## div by int return int
8//3.2       ## div by float return float
```

**Remainder** returns int or float.

```{python, results='hold'}
8%3          ## remainder by int, returns int
8%3.2        ## remainder by float, returns float
```

**Power** returns int or float.

```{python, results='hold'}
2**3         ## power of int to int returns int
2**3.2       ## power to float returns float
2.3**2       ## power of float returns float
```

## String (str)

Str is an **ordered collection of letters**. 

```{python, results='hold'}
s = 'abcde'
type(s)      ## class str
type(s[0])   ## class str
len(s)       ## number of characters
```


### Constructor

```
class str(object='')
class str(object=b'', encoding='utf-8', errors='strict')
```

```{python, results='hold'}
## these are the same
str()          ## empty string
''             ## short hand

## these are the same
str('abc')     ## constructor
'abc'          ## short hand
```

**Multi-line**

Note the result contains **```\n```** at the front of the string, due to a return at the beginning.

```{python}
## multiline
'''
This is me.
Yong Keh Soon'''
```

### Immutable

- **```str```** object is **immutable**. Reassigning a value completely reinitialize it with different memory location.

```{python, results='hold'}
s = 'abcde'
id(s)

s = '12345'   ## Reinitialize it as different object
id(s)         ## hence the ID is now different
```

### Index-able

Although String has **array** like indexable capability, it is not iterateable.

```
string[start:end:step]  # default start:0, end:last, step:1
```
If `step` is negative (reverse), `end` value must be lower than `start` value

```{python, results='hold'}
s = 'abcdefghijk'
s[0]       # first later
s[:3]      # first 3 letters
s[2:8 :2]  # stepping
s[-1]      # last letter
s[-3:]     # last three letters
s[:   :-1] # reverse everything
s[8:2 :-1] # till the end
s[8:2]     # return NOTHING
```


### Class Attributes

```{python, results='hold'}
string.ascii_letters     ## for ASCI chars
string.ascii_lowercase   ## all lower case
string.ascii_uppercase   ## all upper case
string.digits            ## 0 - 9
string.whitespace        ## all white spaces
```

### Instance Methods

#### Substitution & Formatting (format, fstring) {-}

**By Variable Name** - supported by ```fstring()```

```fstring``` is useful in a way that you can use variable name within the text directly, and you can format the output too.

```{python, results='hold'}
a = 'a'
b = 'b'
c = 'c'

f"{a} + {b} = {c}"                        # fstring method
```

**By Positional** - supported by ```.format()```

```{python, results='hold'}
"{} + {} = {}"   .format('a', 'b', 'c')   # format: auto sequence 
"{0} + {1} = {2}".format('a', 'b', 'c')   # format: manual sequence
```

**By Name of parameters or dict** - supported by ```.format()```

```{python, results='hold'}
longitude = '-115.81W'
latitude = '37.24N'
"Coordinates: {latitude}, {longitude}".format(latitude='37.24N', longitude='-115.81W') ## constant

## dictionary key/value
coord = {'latitude':  '37.24N', 
         'longitude': '-115.81W'} 
'Coordinates: {latitude}, {longitude}'.format(**coord)  ## dictionary key/value

```

**Formatting Number** 

With **```.format()```** Format numbers by using **```{: . , f %}```**.

```{python, results='hold'}
a = 3.14
b =-3.14

'{:+f}; {:+f}'.format(3.14, -3.14)     ## show +ve -ve sign
'{: f}; {: f}'.format(3.14, -3.14)     ## show only -ve sign
'{:.1f}; {:.1f}'.format(3.15, -3.16)   ## round down/up
'{0:,}'.format(1234567890.4455)        ## show decimal and %
'{0:,.2f}'.format(1234567890.4455)     ## show comma, float decimal
'{0:,.2%}'.format(1234567890.4455)     ## show comma, % decimal
```

Similar result can be achieved using **```fstring```**, by just replacing by putting variable names inline.

```{python, results='hold'}
a = 3.14
b =-3.14
c = 1234567890.4455

f'{a:+f}; {b:+f}'       ## show +ve -ve sign
f'{a: f}; {b: f}'       ## show only -ve sign
f'{a:.1f}; {b:.1f}'     ## round down/up
f'{c:,}'                ## show decimal and %
f'{c:,.2f}'             ## show comma, float decimal
f'{c:,.2%}'             ## show comma, % decimal
```

**Alignment**

```{python, results='hold'}
'{:*^43}'.format('centered')                 ## '*' filler applied   
'{0:<20}   {0:*<20}'.format('left aligned')  ## '*' filler applied   
'{0:*>20}  {0:>20}'.format('right aligned')  ## '*' filler applied   
''
'{:^43}'.format('centered')                  ## no filler
'{0:<20}   {0:<20}'.format('left aligned')   ## no filler
'{0:>20}  {0:>20}'.format('right aligned')   ## no filler
```

Similar result can be achieved using **```fstring```**, which is more concised.

```{python, results='hold'}
center = 'centered'
left   = 'left aligned'
right  = 'right aligned'

f'{center:*^43}'                 ## '*' filler applied   
f'{left:<20}   {left:*<20}'      ## '*' filler applied   
f'{right:*>20}  {right:>20}'     ## '*' filler applied   
f''
f'{center:^43}'                  ## no filler
f'{left:<20}   {left:<20}'       ## no filler
f'{right:>20}  {right:>20}'      ## no filler
```

#### Case Conversion (upper/lower) {-}

```{python, results='hold'}
'myEXEel.xls'.upper()
'myEXEel.xls'.lower()
```


#### Searh Location (find)  {-}

**```.find()```** returns position of first occurance, -1 if not found, and it is **case sensitive**.

```{python, results='hold'}
s='I love karaoke, I know you love it too'
s.find('lov')         ## found
s.find('Lov1')    ## not found, return -1
```

#### Striping off blank spaces  (strip) {-}

**Leading** and **trailing** blank spaces (newline, tab, cr) will be removed.

```{python, results='hold'}
'\n   myexce l.   xls   \r\t\n'.strip()   ## strip both leading and trailing
'\n   myexce l.   xls   \r\t\n'.lstrip()  ## strip leading only
'\n   myexce l.   xls   \r\t\n'.rstrip()  ## strip trailing only
```

#### Split and Join (split, join)

**```split('<delimiter>')```** breaks down string into a list by delimiter. Observe the empty spaces were conserved in result array

```{python}
animals = 'a1,a2 ,  a3 , a4'
animals.split(',')
```

**```'<delimiter>.join()```** is the reverse of split.

```{python}
'-'.join(['1', '2', '3', '4'])
```

#### Replacement (repalce) {-}

**```replace`(old, new, count=-1)```** is case sensitive. By default, it replaces all occurances (count=-1).

```{python, results='hold'}
s = "geeks for geeks geeks geeks geeks" 
s.replace("geeks", "Geeks")     ## default replace all
s.replace("geeks", "Geeks", 3)  ## replace 3 times
```
 
### Operators

#### Old Style Substitution (%)

https://docs.python.org/3/library/stdtypes.html#old-string-formatting

```{python}
my_name = 'Yong Keh Soon'
salary  = 11123.346
'Hello, %s, your salary is %.2f !' %(my_name, salary)
```

#### Concatenation (+)

```{python}
'this is ' + 'awesome'
```

#### Is Inside (in)

For single string, **partial match**

```{python}
print( 'abc' in '123abcdefg' )
```

For list of strings, **exact match** (even though only one element in list).  
For partial match, workaround is to **convert list to single string**

```{python}
print( 'abc' in ['abcdefg'],             # false
       'abc' in ['abcdefg','123'],       # fakse
       'abc' in ['123','abc','def'],     # true
       'abc' in str(['123','abcdefg']))  # true
```

#### Comparitor

Comparitor compares the memory address.

```{python, results = 'hold'}
a = str('abc')
b = str('abc')
id(a) == id(b)
```

## Boolean

```{python}
b = False

if (b):
    print ('It is true')
else:
    print ('It is fake')
```

### What is Considered False ?

Everything below are false, **anything else are true**

```{python}
print ( bool(0),      # zero
        bool(None),  # none
        bool(''),    # empty string
        bool([]),    # empty list
        bool(()),    # empty tupple
        bool(False), # False
        bool(2-2))    # expression that return any value above
```

### ```and``` operator

BEWARE !  

- **and** can return different data types  
- If evaluated result is **True**, the last **True Value** is returned (because python need to evaluate up to the last value)  
- If evaluated result is **False**, the first **False Value** will be returned (because python return it immediately when detecting False value)

```{python}
print (123 and 2 and 1,
       123 and [] and 2)
```

### ```not``` operator

```{python}
not (True)
not (True or False)
not (False)
not (True and False)
~(False)
```

### ```or``` operator
- **or** can return different data type  
- If evaluated result is True, first **True Value** will be returned  (right hand side value **need not be evaluated**)  
- If evaluated result is False, last **Fasle Value** will be returned (need to evalute all items before concluding False)

```{python}
print (1 or 2)
print (0 or 1 or 1)
print (0 or () or [])
```


## None

### None is an Object

- None is a Python **object NonType**  
- Any operation to None object will result in **error**  
- For array data with None elements, verification is required to check through iteration to determine if the item is not None. It is very computaionaly heavy 

```{python}
type(None)
```

```{python}
import numpy as np

t1 = np.array([1, 2, 3, 4, 5])
t2= np.array([1, 2, 3, None, 4, 5])
print( t1.dtype  , '\n\n',    # it's an object
       t2.dtype)
```

### Comparing None

**Not Prefered Method**

```{python}
null_variable = None
print( null_variable == None )
```

**Prefered**

```{python}
print( null_variable is None )
print( null_variable is not None )
```

### Operation on None

Any operator (except `is`) on None results in error.

```{python, error = TRUE}
None & None
```

