# Built-In Data Structure

## Tuple

Tuple is an **immutable list**. Any attempt to change/update tuple will return error. It can contain **different types** of object just like **list**.

Benefits of tuple against List are:

- Tuple is **Faster** than list
- Tuple **Protects** your data against accidental change
- Can be used as key in dictionaries, list can't

### Creation

Tuple is created through assignment with or without brackets. To create tuple from list, use **tuple()** constructor.

```{python}
t1 = (1,2,3,'o',(4,5,6))                   ## with brackets
t2 = 1,2,3,'o','apple', (4,5,6)            ## without brackets
t3 = tuple([1,2,3,'o','apple', (4,5,6)])   ## create from list using constructor

print(type(t1), type(t2), type(t3))
```

### Accessor

Assessing single element returns the element. Assessing range of elements returns tuple.

```{python}
print( t1[0], t1[1:3] )
```

### Copy and Clone

Use normal assignment **=** to duplicate. Reference of the memory address is copied. Data is actually not duplicated in memory. To clone an tuple (different ID), convert to list then back to tuple again.

```{python}
## Copy actually points to the same memory location
original   = (1,2,3,4,5)
copy_test  = original
clone_test = tuple(list(original)) ## convert to list then back to tuple

## The copy refers to the same content
print(original)
print(copy_test)
print(clone_test)

## Copy and original has the same memory location.
print('Original ID: ', id(original))
print('Copy ID:     ', id(copy_test))
print('Clone ID:    ', id(clone_test))  ## clone has different ID
```

## List

- List is a collection of **ordered** items, where the items **can be different data types**  
- You can pack list of items by placing them into **[]**
- List is mutable

### Creation

```{python, results='hold'}
## Create Empty List
empty = []      # literal assignment method
empty = list()  # constructor method

multiple = [123,'abc',456, None] ## multiple datatypes allowed
str_list = list('hello')         ## [split into h,e,l,l,o]

multiple
str_list
```

### Accessor

Use **[]** to specify single or range of objects to return. Index numner starts from **0**.

```{python, results='hold'}
food = ['bread', 'noodle', 'rice', 'biscuit','jelly','cake']

## Accessing Single Index, Returns Object
food[2]  # 3rd item
food[-1] # last item

## Accessing Range Of Indexes, Return List
food[:4]     # first 3 items
food[-3:]    # last 3 items
food[1:5]    # item 1 to 4
food[5:2:-1] # item 3 to 5, reverse order
food[::-1]   # reverse order
```

### Methods

All methods shown below is "inplace", meaning the original data will be changed.

**Remove Item(s)**

Removal of non-existence item will result in error

```{python, results='hold'}
food = list(['bread', 'noodle', 'rice', 'biscuit','jelly','biscuit','noodle'])
food.remove('biscuit')     ## remove first found element
food.pop()         ## remove last element, and return it
food.pop(1)        ## remove second element, and return it
food
```

**Appending**

There are two methods to add elements to the tail. **append()** adds single element. **extend()** addes multiple elements.

```{python, results='hold'}
food.append('durian')        ## add single element to the tail 
food.extend(['nand','puff']) ## add elements to the tail
food
```

**Other Methods**

```{python, results='hold'}
## ordering of elements
food.reverse()          ## reverse current order
food.sort()             ## sort ascending
food.sort(reverse=True) ## sort descending
food

## methods returning number
food.index('biscuit')   ## return the index of first found element
food.count('biscuit')   ## return occurance of element
```
### Operators

**Concatenation**

Two lists can be concatenated using '+' operator.

```{python, collapse=TRUE}
animals = ['dog','cat','horse'] + ['elephant','tiger'] + ['sheep']
```

**List is Mutable**

The reference of list variable won't change after adding/removing its item

```{python, results='hold'}
id(animals)
animals += ['chicken']
animals.pop()
id(animals)  ## ID had not changed
```

**Copy and Clone**

Assignment to another variable always refers to the same data.Use **copy()** method if you wish to clone the data, with different ID.

```{python, results='hold'}
original   = [1,2,3,4,5]      ## original data
copy_test  = original         ## same ID as Original
clone_test = original.copy()  ## different ID
print( id(original), id(copy_test), id(clone_test))
```

**Passing To Function As Reference**

When passing list to functions, only the reference passed. Meaning all changes to the list within the function will be reflected outside the function.

```{python, results='hold'}
my_list = [1,2,3,4,5]

def func(x):
    print (x)
    print('ID in Function:      ', id(x))
    x.append(6)    ## modify the refrence

my_list
id(my_list)

func(my_list)  ## passing reference to function

my_list        ## content was altered
id(my_list)
```

### Iteration

**For Loop**

```{python, results='hold'}
mylist = ['abc','abcd','bcde','bcdee','cdefg']
for x in mylist:
    if 'abc' in x:
        print (x)
```

**List Comprehension**

This code below is a short-form method of **for loop and if**. The output of list comprehension is a new **list**.

```{python, results='hold'}
old_list = ['abc','abcd','bcde','bcdee','cdefg']
[x for x in old_list if 'abc' in x]
```

Code below is a long-version compared to list comprehension aboce.

```{python, results='hold'}
new_list = []
old_list = ['abc','abcd','bcde','bcdee','cdefg']
for x in old_list:
    if 'abc' in x:
        new_list.append(x)
        
new_list
```

### Tuple Conversion

```{python, results='hold'}
my_list  = [1,2,3]
my_tuple = tuple(my_list)   ## concert to tuple using constructor

my_list
my_tuple
```
### Built-In Functions

```{python, results='hold'}
my_numbers = [1,2,3,5,5,3,2,1]

len(my_numbers)    ## numner of elements
max(my_numbers)    ## maximum value of elements
sorted(my_numbers) ## sort ascending
sorted(my_numbers, reverse=True) ## sort descending
```

## Dictionaries

Dictionary is a list of index-value items.

### Creation

**Simple Dictionary**

```{python, results='hold'}
empty_dict    = {}   ## create empty
animal_counts = { 'cats' : 2, 'dogs' : 5, 'horses':4}
type(animal_counts)
type(empty_dict)
```

**Dictionary with list**

```{python, results='hold'}
horse_names  = ['Sax','Jack','Ann','Jeep']
animal_names = {'cats':   ['Walter','Ra'],
                'dogs':   ['Jim','Roy','John','Lucky','Row'],
                'horses': horse_names
               }
animal_names
```

### Accessor

**Get All Keys**

```{python, results='hold'}
animal_name_keys = animal_names.keys()
animal_name_keys               ## it is a list
[x for x in animal_name_keys]  ## it is iterable

```

**Get All Values**

```{python, results='hold'}
animal_name_values = animal_names.values()
animal_name_values               ## it is a list
[x for x in animal_name_values]  ## values are iterable
```

**Acceess With Key**

Use **`[ key ]`** notation to get its value. However, this will return **Error** if key does not exist

```{python, results='hold'}
animal_names['dogs']
```

For a safer approach (not to return error when key doesn't exist), use  **`get( key )`** notation. It will return None if key does not exist

```{python, results='hold'}
animal_names.get('cow')   ## does not exist, return None
animal_names.get('dogs')

```

### MACD

**Update/Append**

Use **`[key]`** notation to **update** or **append** the content of element. Use **`del`** to remove a key/value pair.

```{python, results='hold'}
new_world = {}                                 ## create empty
new_world['bacteria'] = ['Ameoba','Fractona']  ## add new key/value
new_world['alien']    = ['Ali','Abu']          ## add new key/value
new_world
new_world['bacteria'] = ['Mutu', 'Aru']        ## Update value
del new_world['alien']                         ## delete key/value
new_world
```

Use **`clear()`** to erase all elements

```{python, results='hold'}
animal_names.clear()
animal_names  ## now an empty dict
```

### Iteration

Example below shows how to iterate over keys (**`.keys()`**), values (**`.values()`**) and both key/values (**`.items()`**).

```{python,  results='hold'}
animal_dict = { 'cats' : 2, 'dogs' : 5, 'horses':4}

[ (key,val) for key,val in animal_dict.items()] 
[x for x in animal_dict.values()]  ## values are iterable
[x for x in animal_dict.keys()]    ## keys are iterable
```

## Sets

Set is **unordered** collection of **unique items**. Set is **mutable**

### Creation

Set can be declared with **`{}`**, just like list creation uses **'[]'**.

```{python,  results='hold'}
myset = {'a','b','c','d','a','b','e','f','g'}
myset # notice no repetition values
```

Set can be created from list, and then converted back to list. This is the perfect way to make a list unique.

```{python,  results='hold'}
mylist = ['a','b','c','d','a','b','e','f','g']
myset = set(mylist)
my_unique_list = list(myset)
print (
  'Original List       : ', mylist,
  '\nConvert to set      : ', myset,
  '\nConvert back to list: ', my_unique_list) # notice no repetition values
```

### Operators

**Membership Test**

```{python,  results='hold'}
'a' in myset      # is member ?
'f' not in myset  # is not member ?
```

**Subset Test**

Subset Test : **`<=`**  
Proper Subset Test : **`<`**

```{python,  results='hold'}
mysubset = {'d','g'}
mysubset <= myset
```

Proper Subset test that the master set **contain at least one element** which is not in the subset

```{python,  results='hold'}
mysubset = {'b','a','d','c','e','f','g'}
print ('Is Subset : ', mysubset <= myset)
print ('Is Proper Subet : ', mysubset < myset)
```

**Union using `|`**

```{python,  results='hold'}
{'a','b','c'} | {'a','e','f'}
```

**Intersection using `&`**

Any elments that exist in both left and right set

```{python,  results='hold'}
{'a','b','c','d'} & {'c','d','e','f'}
```

**Difference using `-`**

Remove **right** from **left**

```{python}
{'a','b','c','d'} - {'c','d','e','f'}
```
